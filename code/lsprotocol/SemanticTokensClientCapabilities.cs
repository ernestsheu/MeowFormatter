// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// 
// THIS FILE IS AUTOGENERATED, DO NOT MODIFY IT

using Newtonsoft.Json;
using System.Collections.Immutable;
using System.Runtime.Serialization;

namespace Microsoft.LanguageServer.Protocol {
    /// <summary>
    /// </summary>
    [Since("3.16.0")]
    [DataContract]
    public record SemanticTokensClientCapabilities
    {
        [JsonConstructor]
        public SemanticTokensClientCapabilities(
            ClientSemanticTokensRequestOptions requests,
            ImmutableArray<string> tokenTypes,
            ImmutableArray<string> tokenModifiers,
            ImmutableArray<TokenFormat> formats,
            bool? dynamicRegistration = null,
            bool? overlappingTokenSupport = null,
            bool? multilineTokenSupport = null,
            bool? serverCancelSupport = null,
            bool? augmentsSyntaxTokens = null
        )
        {
            DynamicRegistration = dynamicRegistration;
            Requests = requests;
            TokenTypes = tokenTypes;
            TokenModifiers = tokenModifiers;
            Formats = formats;
            OverlappingTokenSupport = overlappingTokenSupport;
            MultilineTokenSupport = multilineTokenSupport;
            ServerCancelSupport = serverCancelSupport;
            AugmentsSyntaxTokens = augmentsSyntaxTokens;
        }
        /// <summary>
        /// Whether implementation supports dynamic registration. If this is set to `true`
        /// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
        /// return value for the corresponding server capability as well.
        /// </summary>
        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        [DataMember(Name = "dynamicRegistration")]
        public bool? DynamicRegistration { get; init; }
        /// <summary>
        /// Which requests the client supports and might send to the server
        /// depending on the server's capability. Please note that clients might not
        /// show semantic tokens or degrade some of the user experience if a range
        /// or full request is advertised by the client but not provided by the
        /// server. If for example the client capability `requests.full` and
        /// `request.range` are both set to true but the server only provides a
        /// range provider the client might not render a minimap correctly or might
        /// even decide to not show any semantic tokens at all.
        /// </summary>
        [DataMember(Name = "requests")]
        public ClientSemanticTokensRequestOptions Requests { get; init; }
        /// <summary>
        /// The token types that the client supports.
        /// </summary>
        [JsonConverter(typeof(CustomArrayConverter<string>))]
        [DataMember(Name = "tokenTypes")]
        public ImmutableArray<string> TokenTypes { get; init; }
        /// <summary>
        /// The token modifiers that the client supports.
        /// </summary>
        [JsonConverter(typeof(CustomArrayConverter<string>))]
        [DataMember(Name = "tokenModifiers")]
        public ImmutableArray<string> TokenModifiers { get; init; }
        /// <summary>
        /// The token formats the clients supports.
        /// </summary>
        [JsonConverter(typeof(CustomArrayConverter<TokenFormat>))]
        [DataMember(Name = "formats")]
        public ImmutableArray<TokenFormat> Formats { get; init; }
        /// <summary>
        /// Whether the client supports tokens that can overlap each other.
        /// </summary>
        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        [DataMember(Name = "overlappingTokenSupport")]
        public bool? OverlappingTokenSupport { get; init; }
        /// <summary>
        /// Whether the client supports tokens that can span multiple lines.
        /// </summary>
        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        [DataMember(Name = "multilineTokenSupport")]
        public bool? MultilineTokenSupport { get; init; }
        /// <summary>
        /// Whether the client allows the server to actively cancel a
        /// semantic token request, e.g. supports returning
        /// LSPErrorCodes.ServerCancelled. If a server does the client
        /// needs to retrigger the request.
        /// 
        /// </summary>
        [Since("3.17.0")]
        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        [DataMember(Name = "serverCancelSupport")]
        public bool? ServerCancelSupport { get; init; }
        /// <summary>
        /// Whether the client uses semantic tokens to augment existing
        /// syntax tokens. If set to `true` client side created syntax
        /// tokens and semantic tokens are both used for colorization. If
        /// set to `false` the client only uses the returned semantic tokens
        /// for colorization.
        /// 
        /// If the value is `undefined` then the client behavior is not
        /// specified.
        /// 
        /// </summary>
        [Since("3.17.0")]
        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        [DataMember(Name = "augmentsSyntaxTokens")]
        public bool? AugmentsSyntaxTokens { get; init; }
    }

}
